## 1: zookeeper的节点类型：
* 1、PERSISTENT
持久化目录节点
客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，他将永远存在
* 2、 PERSISTENT_SEQUENTIAL
持久化顺序编号目录节点
客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号
* 3、EPHEMERAL
临时目录节点
客户端与zookeeper断开连接后，该节点被删除
* 4、EPHEMERAL_SEQUENTIAL
临时顺序编号目录节点
客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号
* 5、 Container 节点（3.5.3 版本新增，如果Container节点下面没有子节点，则Container节点
在未来会被Zookeeper自动清除,定时任务默认60s 检查一次）
* 6、 TTL 节点( 默认禁用，只能通过系统配置 zookeeper.extendedTypesEnabled=true 开启，不稳
定)
![](images\zk节点类型.jpg)

## 2： 监听通知机制
[代码地址]: ../../zookeeper/zookeeper-springboot/src/main/java/com/ithawk/demo/zookeeper/springboot/utils/ZookeeperUtils.java	"zookeeper操作工具类"

客户端注册监听它关心的任意节点，或者目录节点及递归子目录节点

1. 如果注册的是对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通知

2. 如果注册的是对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对应的客户端将被通知

3. 如果注册的是对某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结构的变化（有子节点被创建，或被删除）或者根节点有数据变化时，对应的客户端将被通知。

4. 注意：所有的通知都是一次性的，及无论是对节点还是对目录进行的监听，一旦触发，对应的监听即被移除。递归子节点，监听是对所有子节点的，所以，每个子节点下面的事件同样只会被触发一次。

  ![](images\zkWatch.jpg)

## 3：Zookeeper 的 ACL 权限控制( Access Control List )

Zookeeper 的ACL 权限控制,可以控制节点的读写操作,保证数据的安全性，Zookeeper ACL 权
限设置分为 3 部分组成，分别是：权限模式（Scheme）、授权对象（ID）、权限信息
（Permission）。最终组成一条例如"scheme:id:permission"格式的 ACL 请求信息。下面我
们具体看一下这 3 部分代表什么意思：

* Scheme（权限模式）：用来设置 ZooKeeper 服务器进行权限验证的方式。ZooKeeper 的权限
  验证方式大体分为两种类型：
  - 一种是范围验证。所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某
    种权限。比如我们可以让一个 IP 地址为“ip：192.168.0.110”的机器对服务器上的某个数据节
    点具有写入的权限。或者也可以通过“ip:192.168.0.1/24”给一段 IP 地址的机器赋权。
  - 另一种权限模式就是口令验证，也可以理解为用户名密码的方式。在 ZooKeeper 中这种验证方
      式是 Digest 认证，而 Digest 这种认证方式首先在客户端传送“username:password”这种形
      式的权限表示符后，ZooKeeper 服务端会对密码 部分使用 SHA-1 和 BASE64 算法进行加密，
      以保证安全性。
      还有一种Super权限模式, Super可以认为是一种特殊的 Digest 认证。具有 Super 权限的客户端
      可以对 ZooKeeper 上的任意数据节点进行任意操作。

* 授权对象（ID）
  授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP
  方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则
  对应于一个用户名。如果是 World 模式，是授权系统中所有的用户。
* 权限信息（Permission）
    权限就是指我们可以在数据节点上执行的操作种类，如下所示：在 ZooKeeper 中已经定义好的权限有 5 种：
	- 数据节点（c: create）创建权限，授予权限的对象可以在数据节点下创建子节点；
	- 数据节点（w: wirte）更新权限，授予权限的对象可以更新该数据节点；
	- 数据节点（r: read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的列表信息；
	- 数据节点（d: delete）删除权限，授予权限的对象可以删除该数据节点的子节点；
	- 数据节点（a: admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。

## 4: Zookeeper 集群模式：

Zookeeper 集群模式一共有三种类型的角色

* Leader: 处理所有的事务请求（写请求），可以处理读请求，集群中只能有一个Leader

* Follower：只能处理读请求，同时作为 Leader的候选节点，即如果Leader宕机，Follower节点要参与到新的Leader选举中，有可能成为新的Leader节点。

* Observer：只能处理读请求。不能参与选举

  

### Zookeeper 3.5.0 新特性： 集群动态配置

Zookeeper 3.5.0 以前，Zookeeper集群角色要发生改变的话，只能通过停掉所有的Zookeeper服务，修改集群配置，重启服务来完成，这样集群服务将有一段不可用的状态，为了应对高可用需求，Zookeeper 3.5.0 提供了支持动态扩容/缩容的 新特性。但是通过客户端API可以变更服务端集群状态是件很危险的事情，所以在zookeeper 3.5.3 版本要用动态配置，需要开启超级管理员身份验证模式 ACLs。如果是在一个安全的环境也可以通过配置 系统参数 -Dzookeeper.skipACL=yes 来避免配置维护acl 权限配置。



## 5：Zookeeper分布式锁实战

### 非公平锁

![](images\zk非公平锁.jpg)

如上实现方式在并发问题比较严重的情况下，性能会下降的比较厉害，主要原因是，所有的连接
都在对同一个节点进行监听，当服务器检测到删除事件时，要通知所有的连接，所有的连接同时
收到事件，再次并发竞争，这就是羊群效应。如何避免呢，我们看下面这种方式。

### 公平锁

![](images\zk公平锁.jpg)

如上借助于临时顺序节点，可以避免同时多个节点的并发竞争锁，缓解了服务端压力。

### Zookeeper 共享锁实现原理

![](images\zk共享锁.jpg)

## 6：ZAB协议

ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。
Zookeeper 是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper 并没有使用 Paxos ，而是采
用了 ZAB 协议，ZAB是Paxos算法的一种简化实现。
ZAB 协议定义：ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持 崩溃恢复 和 原子广播 协议。下面我们会重点讲这两个东
西。
基于该协议，Zookeeper 实现了一种 主备模式 的系统架构来保持集群中各个副本之间数据一致性：

![](images\zab协议.jpg)

上图显示了 Zookeeper 如何处理集群中的数据。所有客户端写入数据都是写入到 主进程（称为 Leader）中，然后，由 Leader 复制到备
份进程（称为 Follower）中。从而保证数据一致性。
那么复制过程又是如何的呢？复制过程类似 2PC，ZAB 只需要 Follower 有一半以上返回 Ack 信息就可以执行提交，大大减小了同步阻
塞。也提高了可用性。
简单介绍完，开始重点介绍 消息广播 和 崩溃恢复。整个 Zookeeper 就是在这两个模式之间切换。 简而言之，当 Leader 服务可以正常使用，就进入消息广播模式，当 Leader 不可用时，则进入崩溃恢复模式。

### 消息广播

ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 二阶段提交过程。对于客户端发送的写请求，全部由 Leader 接收，
Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行
commit 操作。

![](images\广播消息.jpg)



还有一些细节：
1. Leader 在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一 ID，称为事务
    ID（ZXID），ZAB 协议需要保证事务的顺序，因此必须将每一个事务按照 ZXID 进行先后排序然后处理，主要通过消息队列实现。

2. 在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞。

3. zookeeper集群中为保证任何所有进程能够有序的顺序执行，只能是 Leader 服务器接受写请求，即使是 Follower 服务器接受到
    客户端的写请求，也会转发到 Leader 服务器进行处理，Follower只能处理读请求。

4. ZAB协议规定了如果一个事务在一台机器上被处理(commit)成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障
    崩溃。

### 崩溃恢复

 ZAB 定义了 2 个原则：

  1. ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。
  2. ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。

所以，ZAB 设计了下面这样一个选举算法：能够确保提交已经被 Leader 提交的事务，同时丢弃已经被跳过的事务。针对这个要求，如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群中所有机器 ZXID 最大的事务，那么就能够保证这个新选举出来的 Leader 一定具有所有已经提交的提案。而且这么做有一个好处是：可以省去 Leader 服务器检查事务的提交和丢弃工作的这一步操作。

### 数据同步

当崩溃恢复之后，需要在正式工作之前（接收客户端请求），Leader 服务器首先确认事务是否都已经被过半的 Follwer 提交了，即是否完成了数据同步。目的是为了保持数据一致。
当 Follwer 服务器成功同步之后，Leader 会将这些服务器加入到可用服务器列表中。
实际上，Leader 服务器处理或丢弃事务都是依赖着 ZXID 的，那么这个 ZXID 如何生成呢？
答：在 ZAB 协议的事务编号 ZXID 设计中，ZXID 是一个 64 位的数字，其中低 32 位可以看作是一个简单的递增的计数器，针对客户端的
每一个事务请求，Leader 都会产生一个新的事务 Proposal 并对该计数器进行 + 1 操作。
而高 32 位则代表了 Leader 服务器上取出本地日志中最大事务 Proposal 的 ZXID，并从该 ZXID 中解析出对应的 epoch 值(leader选举周
期)，当一轮新的选举结束后，会对这个值加一，并且事务id又从0开始自增。

![](images\ZXID.jpg)

高 32 位代表了每代 Leader 的唯一性，低 32 代表了每代 Leader 中事务的唯一性。同时，也能让 Follwer 通过高 32 位识别不同的
Leader。简化了数据恢复流程。
基于这样的策略：当 Follower 连接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行
比对，比对结果要么回滚，要么和 Leader 同步。
