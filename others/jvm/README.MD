## idea 插件 ：jclasslib byte
然后可以在 view -> show bytecode with jclasslib 进行字节码查看
## JIT

```
逃逸分析包括：
   全局变量赋值逃逸
   方法返回值逃逸
   实例引用发生逃逸
   线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量
 java 1.7 之后 默认开启逃逸分析优化
    -XX:+DoEscapeAnalysis ： 表示开启逃逸分析
    -XX:-DoEscapeAnalysis ： 表示关闭逃逸分析
 TestLockEliminate 锁销除    同样基于逃逸分析，当加锁的变量不会发生逃逸，是线程私有的完全没有必要加锁。
 EscapeAnalysisTest 栈上内存分配 
```

## 常量池

1. final类型的8种基本类型的值会进入常量池。
2. 非final类型（包括static的）的8种基本类型的值，只有double、float、long的值会进入常量 池。
3. 常量池中包含的字符串类型字面量（双引号引起来的字符串值）。

### 静态内部类实现单例
```
静态内部类方式

　　要理解静态内部类方式，首先要理解类加载机制。

　　虚拟机把Class文件加载到内存，然后进行校验，解析和初始化，最终形成java类型，这就是虚拟机的类加载机制。加载，验证，准备，解析、初始化这5个阶段的顺序是确定的，类的加载过程，必须按照这种顺序开始。这些阶段通常是相互交叉和混合进行的。解析阶段在某些情况下，可以在初始化阶段之后再开始---为了支持java语言的运行时绑定（动态绑定，多态的原理）。

　　在Java虚拟机规范中，没有强制约束什么时候要开始加载，但是，却严格规定了几种情况必须进行初始化（加载，验证，准备则需要在初始化之前开始）：

　　1. 遇到 new、getstatic、putstatic、或者invokestatic 这4条字节码指令，如果没有类没有进行过初始化，则触发初始化

　　2. 使用java.lang.reflect包的方法，进行反射调用的时候，如果没有初始化，则先触发初始化

　　3. 初始化一个类时候，如果发现父类没有初始化，则先触发父类的初始化

　　我们仅说与本期主题相关的初始化阶段：

　　类初始化阶段是类加载过程的最后阶段。在这个阶段，java虚拟机才真正开始执行类定义中的java程序代码。在编译的时候，编译器会自动收集类中的所有静态变量（类变量）和静态语句块（static｛｝块）中的语句合并产生的，编译器收集的顺序是根据语句在java代码中的顺序决定的。收集完成之后，会编译成java类的 static{} 方法，java虚拟机则会保证一个类的static{} 方法在多线程或者单线程环境中正确的执行，并且只执行一次。在执行的过程中，便完成了类变量的初始化。如果我们的java类中，没有显式声明static{}块，如果类中有静态变量，编译器会默认给我们生成一个static{}方法。

　　对于静态变量来说，虚拟机会保证在子类的static{}方法执行之前，父类的static{}方法已经执行完毕（即如果父类没有加载则先加载父类）。由于父类的static{}方法先执行，也就意味着父类的静态变量要优先于子类的静态变量赋值操作。

　　对于实例变量来说，在实例化对象时，JVM会在堆中为对象分配足够的空间，然后将空间清零（即所有类型赋默认值，引用类型为null）。JVM会收集类中的复制语句放于构造函数中执行，如果没有显式声明构造函数则会默认生成一个构造函数。子类默认生成的构造函数第一行默认为super();即如果父类有无参的构造方法，子类会先调用父类的构造方法再调用本身的构造方法。因为它继承父类成员的使用，必须先初始化这些成员。如果父类没有无参的构造方法则子类继承会报错，需要子类通过super显式调用父类的有参构造方法。如果类中显式定义一个或多个构造方法，则不再生成默认构造方法。

　　对于静态变量，上面的描述还不太准确。
   类初始化阶段，JVM保证同一个类的static{}方法只被执行一次，这是静态内部类单例模式的核心。
   JVM靠类的全限定类名以及加载它的类加载器来唯一确定一个类。
   （这个很重要，经常会有这方面的坑！比如反序列化时，被序列化的对象使用java默认的类加载器加载，
   而使用了反序列化的一方使用的框架（如springBoot就有自己的类加载器）强制使用自己的类加载器加载某个类，
   则会因为JVM判定不是一个类而报ClassNotFoundException！）

　　所以修正一下的说法便是，静态内部类单例模式的核心原理为对于一个类，JVM在仅用一个类加载器加载它时，静态变量的赋值在全局只会执行一次！

　　使用静态内部类的优点是：因为外部类对内部类的引用属于被动引用，不属于前面提到的三种必须进行初始化的情况，所以加载类本身并不需要同时加载内部类。在需要实例化该类是才触发内部类的加载以及本类的实例化，做到了延时加载（懒加载），节约内存。同时因为JVM会保证一个类的<cinit>()方法（初始化方法）执行时的线程安全，从而保证了实例在全局的唯一性。
```

```java
public class Student {
    private Student() {
    }

    /**
    * 此处使用一个内部类来维护单例 JVM在类加载的时候，是互斥的，所以可以由此保证线程安全问题
    */
    private static class SingletonFactory {
        private static Student student = new Student();
    }

    /* 获取实例 */
    public static Student getSingletonInstance() {
        return SingletonFactory.student;
    }
}
```
## 字符串常量池如何存储数据
```
在jdk7+， StringTable 的长度可以通过一个参数指定：
stringtable是类似于hashtable的数据结构，hashtable数据结构如下：
-XX:StringTableSize=9999
```
